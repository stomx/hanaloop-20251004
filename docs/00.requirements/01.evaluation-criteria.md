# 평가 기준 (Evaluation Criteria)

## 개요

이 문서는 과제를 평가하는 기준과 각 항목의 가중치, 세부 평가 요소를 상세히 설명합니다.

## 평가 루브릭

| 평가 항목 | 가중치 | 설명 |
|---------|--------|------|
| **창의성과 비판적 사고** | 25% | 문제 해결 접근법, 질문 제기, 가정 문서화 |
| **탄탄한 UI/UX 디자인과 심미성** | 25% | 현대적 디자인, 직관성, 일관성, 색상 활용 |
| **UI 엔지니어링** | 20% | 반응형 레이아웃, 로딩/에러 처리, 상태 분리 |
| **소프트웨어 엔지니어링** | 20% | 모듈성, 성능, 확장 가능성 |
| **코드 품질** | 10% | 가독성, 타입 사용, 테스트, 커밋 히스토리 |

**총점**: 100%

---

## 1. 창의성과 비판적 사고 (25%)

### 평가 내용

이 항목은 단순히 요구사항을 구현하는 것을 넘어, **어떻게 생각하고 문제를 해결했는가**를 평가합니다.

### 세부 평가 요소

#### 1.1 모호함 식별 (30%)

**우수 사례**:

- 요구사항에서 명확하지 않은 부분을 발견하고 질문 제기
- 가능한 해석을 여러 개 제시하고 선택한 이유 설명

**예시**:

```markdown
## Questions & Assumptions

### Question: Multiple Posts per Month?
- **Question**: Can a company have multiple posts for the same month?
- **Assumption**: Yes, allowing multiple posts for flexibility.
- **Rationale**: Real-world scenarios may require multiple updates per month.
```

#### 1.2 합리적인 확장 제안 (30%)

**우수 사례**:

- 요구사항을 넘어서는 기능을 제안하고 구현 (시간이 허락한다면)
- 미래 확장 가능성을 고려한 설계

**예시**:

- 탄소세 계산기 추가
- 목표 대비 실적 추적
- 배출량 예측 기능
- Export 기능

#### 1.3 가정 문서화 (20%)

**우수 사례**:

- 모든 주요 가정을 명확히 문서화
- 가정을 세운 이유 설명
- 대안을 고려했음을 보여줌

#### 1.4 흥미로운 아이디어 (20%)

**우수 사례**:

- 사용자 경험을 향상시키는 독창적인 기능
- 데이터를 새로운 방식으로 시각화
- 문제를 우아하게 해결하는 접근법

**예시**:

- 드래그 앤 드롭으로 차트 순서 변경
- 차트 간 연동 필터링 (한 차트에서 선택하면 다른 차트도 업데이트)
- 배출량 추세 예측 기능

### 채점 가이드

- **Excellent (90-100%)**: 여러 질문 제기, 명확한 가정 문서화, 독창적 아이디어 구현
- **Good (70-89%)**: 일부 가정 문서화, 기본적인 확장 고려
- **Acceptable (50-69%)**: 최소한의 가정 문서화
- **Poor (< 50%)**: 가정 문서화 없음, 기계적 구현만

---

## 2. 탄탄한 UI/UX 디자인과 심미성 (25%)

### 평가 내용

시각적 매력, 사용 편의성, 일관성을 평가합니다.

### 세부 평가 요소

#### 2.1 현대적인 룩 앤 필 (30%)

**우수 사례**:

- 2024-2025년 디자인 트렌드 반영
- 클린하고 미니멀한 인터페이스
- 적절한 여백과 타이포그래피
- 프로페셔널한 느낌

**체크리스트**:

- [ ] 일관된 폰트 사용
- [ ] 적절한 색상 대비
- [ ] 균형 잡힌 레이아웃
- [ ] 시각적 계층 구조 명확

#### 2.2 직관적 인터페이스 (30%)

**우수 사례**:

- 사용자가 설명 없이 사용 가능
- 예측 가능한 동작
- 명확한 피드백 (호버, 클릭, 상태 변화)
- 일반적인 UX 패턴 따름

**평가 포인트**:

- 필터가 쉽게 발견되고 사용 가능한가?
- 차트가 직관적으로 이해되는가?
- 버튼과 액션이 명확한가?
- 에러 메시지가 도움이 되는가?

#### 2.3 일관된 UI 컴포넌트 (20%)

**우수 사례**:

- 통일된 버튼 스타일
- 일관된 색상 사용
- 재사용 가능한 컴포넌트
- 디자인 시스템 적용

#### 2.4 균형 잡힌 컬러 팔레트 (20%)

**우수 사례**:

- 2-3개의 주요 색상
- 적절한 액센트 색상
- 색상이 의미를 전달 (녹색=감소, 빨간색=증가)
- 접근성 고려 (WCAG AA 이상)

### 채점 가이드

- **Excellent (90-100%)**: 매력적이고 현대적, 매우 직관적, 완벽한 일관성
- **Good (70-89%)**: 깔끔한 디자인, 대체로 직관적, 일관성 있음
- **Acceptable (50-69%)**: 기본적인 스타일링, 사용 가능한 수준
- **Poor (< 50%)**: 스타일링 미흡, 일관성 없음

---

## 3. UI 엔지니어링 (20%)

### 평가 내용

기술적 구현의 견고함과 사용자 경험 품질을 평가합니다.

### 세부 평가 요소

#### 3.1 반응형 레이아웃 (40%)

**우수 사례**:

- 모바일, 태블릿, 데스크톱 모두 지원
- 적절한 브레이크포인트 사용
- 모든 기기에서 기능 작동
- 콘텐츠가 잘리거나 겹치지 않음

**테스트 포인트**:

- [ ] 모바일 (< 640px)에서 사용 가능
- [ ] 태블릿 (640-1024px)에서 레이아웃 조정
- [ ] 데스크톱에서 최적화된 경험

#### 3.2 로딩/에러 상태 (40%)

**우수 사례**:

- 모든 비동기 작업에 로딩 표시
- 스켈레톤 스크린 또는 스피너
- 명확한 에러 메시지
- 재시도 옵션 제공
- Empty state 처리

**체크리스트**:

- [ ] 초기 데이터 로드 시 로딩 표시
- [ ] 필터 변경 시 로딩 표시
- [ ] 포스트 저장 중 버튼 비활성화
- [ ] 저장 실패 시 에러 메시지
- [ ] 데이터 없을 때 적절한 메시지

#### 3.3 상태 분리 (20%)

**우수 사례**:

- UI 상태 vs 데이터 상태 명확히 분리
- 필터 상태를 URL이나 전역 상태로 관리
- 서버 데이터와 로컬 상태 구분

**좋은 예시**:

```typescript
// UI State (local)
const [isModalOpen, setIsModalOpen] = useState(false);

// Filter State (global or URL)
const [filters, setFilters] = useFilters();

// Server State (React Query)
const { data, isLoading } = useCompanies();
```

### 채점 가이드

- **Excellent (90-100%)**: 완벽한 반응형, 철저한 로딩/에러 처리, 명확한 상태 분리
- **Good (70-89%)**: 기본 반응형, 주요 로딩/에러 처리, 상태 분리 시도
- **Acceptable (50-69%)**: 데스크톱 중심, 일부 로딩/에러 처리
- **Poor (< 50%)**: 반응형 없음, 로딩/에러 처리 미흡

---

## 4. 소프트웨어 엔지니어링 (20%)

### 평가 내용

코드 아키텍처, 성능, 확장 가능성을 평가합니다.

### 세부 평가 요소

#### 4.1 모듈성 (40%)

**우수 사례**:

- 컴포넌트가 단일 책임 원칙 준수
- 재사용 가능한 유틸리티 함수
- 적절한 폴더 구조
- 관심사 분리

**체크리스트**:

- [ ] UI 컴포넌트와 비즈니스 로직 분리
- [ ] 작고 집중된 컴포넌트
- [ ] 재사용 가능한 훅 (custom hooks)
- [ ] 타입 정의 별도 관리

**좋은 예시**:

```typescript
// ❌ Bad: 모든 것이 한 파일에
function Dashboard() {
  // 100+ lines of mixed logic
}

// ✅ Good: 분리된 컴포넌트
function Dashboard() {
  return (
    <>
      <SummaryCards />
      <ChartsSection />
      <DataTable />
    </>
  );
}
```

#### 4.2 성능 (30%)

**우수 사례**:

- 불필요한 리렌더링 최소화
- 적절한 메모이제이션 (useMemo, useCallback, React.memo)
- 코드 스플리팅 (dynamic imports)
- 효율적인 데이터 구조

**평가 포인트**:

- 필터 변경 시 전체 앱이 리렌더링되지 않는가?
- 큰 리스트를 효율적으로 렌더링하는가?
- 차트 리렌더링이 최적화되었는가?

#### 4.3 확장 가능성 (30%)

**우수 사례**:

- 새로운 기능 추가가 쉬운 구조
- 하드코딩 최소화
- 설정 가능한 컴포넌트
- 일관된 패턴

**평가 질문**:

- 새로운 차트 타입을 추가하기 쉬운가?
- 새로운 필터를 추가하기 쉬운가?
- 데이터 소스 변경이 용이한가?

### 채점 가이드

- **Excellent (90-100%)**: 훌륭한 아키텍처, 성능 최적화, 높은 확장성
- **Good (70-89%)**: 괜찮은 구조, 기본 최적화, 확장 가능
- **Acceptable (50-69%)**: 작동하는 코드, 일부 모듈화
- **Poor (< 50%)**: 스파게티 코드, 성능 문제

---

## 5. 코드 품질 (10%)

### 평가 내용

코드의 가독성, 유지보수성, 테스트 가능성을 평가합니다.

### 세부 평가 요소

#### 5.1 가독성 (40%)

**우수 사례**:

- 명확한 변수/함수 이름
- 적절한 주석 (복잡한 로직만)
- 일관된 코드 스타일
- 적절한 줄바꿈과 들여쓰기

**좋은 예시**:

```typescript
// ❌ Bad
const d = c.reduce((a, e) => a + e.emissions.reduce((b, x) => b + x.emissions, 0), 0);

// ✅ Good
const totalEmissions = companies.reduce((total, company) => {
  const companyTotal = company.emissions.reduce(
    (sum, emission) => sum + emission.emissions,
    0
  );
  return total + companyTotal;
}, 0);
```

#### 5.2 타입 사용 (30%)

**우수 사례**:

- 모든 함수와 컴포넌트에 타입 지정
- `any` 사용 최소화
- 적절한 제네릭 사용
- 타입 안전성 보장

**체크리스트**:

- [ ] Props에 타입 정의
- [ ] 함수 반환 타입 명시
- [ ] API 응답 타입 정의
- [ ] `any` 회피

#### 5.3 구조화 및 네이밍 (20%)

**우수 사례**:

- 논리적인 폴더 구조
- 일관된 파일 네이밍
- 컴포넌트명이 역할을 명확히 표현
- 유틸리티 함수 적절히 그룹화

#### 5.4 커밋 히스토리 (10%)

**우수 사례**:

- 의미 있는 커밋 메시지
- 논리적 단위로 커밋 분리
- 불필요한 파일 제외 (.env, node_modules 등)

**좋은 예시**:

```bash
feat: Add emissions line chart with date range filter
fix: Correct total emissions calculation
refactor: Extract chart components for reusability
docs: Update README with setup instructions
```

### 채점 가이드

- **Excellent (90-100%)**: 매우 읽기 쉬움, 완벽한 타입, 깔끔한 구조, 좋은 커밋
- **Good (70-89%)**: 읽기 쉬움, 대부분 타입 지정, 괜찮은 구조
- **Acceptable (50-69%)**: 이해 가능, 일부 타입, 기본 구조
- **Poor (< 50%)**: 읽기 어려움, 타입 부족, 엉망인 구조

---

## 종합 평가

### 점수 계산

```
최종 점수 = (창의성 × 0.25) + (UI/UX × 0.25) + (UI 엔지니어링 × 0.20) 
           + (소프트웨어 엔지니어링 × 0.20) + (코드 품질 × 0.10)
```

### 등급

- **A+ (95-100%)**: 뛰어난 품질, 요구사항을 크게 초과
- **A (90-94%)**: 매우 우수한 품질, 모든 요구사항 충족
- **B+ (85-89%)**: 우수한 품질, 대부분 요구사항 충족
- **B (80-84%)**: 좋은 품질, 주요 요구사항 충족
- **C+ (75-79%)**: 괜찮은 품질, 기본 요구사항 충족
- **C (70-74%)**: 합격 수준, 최소 요구사항 충족
- **< 70%**: 재검토 필요

## 평가 과정

1. **초기 검토** (10분)
   - 설치 및 실행 가능 여부 확인
   - README 및 문서 검토
   - 전반적인 첫인상

2. **기능 테스트** (20분)
   - 모든 핵심 기능 테스트
   - 다양한 브라우저 크기 확인
   - 로딩/에러 시나리오 테스트

3. **코드 리뷰** (30분)
   - 파일 구조 검토
   - 주요 컴포넌트 읽기
   - 타입 및 로직 검토
   - 커밋 히스토리 확인

4. **문서 검토** (10분)
   - 가정 및 질문 확인
   - 디자인 결정 검토
   - 트레이드오프 이해

5. **채점 및 피드백** (10분)

## 핵심 메시지

### 중요한 것

1. **신중한 트레이드오프**: 왜 이 선택을 했는지 설명
2. **사고 과정**: 어떻게 문제에 접근했는지
3. **핵심 기능의 품질**: 모든 것을 대충 하는 것보다 중요한 것을 잘
4. **문서화**: 결정과 가정을 명확히

### 덜 중요한 것

1. ~~완벽한 구현~~: 시간 제약을 고려
2. ~~모든 기능 구현~~: 우선순위가 더 중요
3. ~~복잡한 알고리즘~~: 명확성이 먼저
4. ~~완벽한 디자인~~: 일관성과 사용성이 먼저

## 자주 묻는 질문

### Q: 테스트를 반드시 작성해야 하나요?

**A**: 필수는 아니지만 권장됩니다. 시간이 부족하면 핵심 유틸리티 함수에 대한 간단한 단위 테스트만 작성하거나, 테스트 계획을 문서화하는 것으로 대체할 수 있습니다.

### Q: 모든 기능을 구현하지 못했는데 괜찮나요?

**A**: 네, 괜찮습니다. 중요한 것은 구현한 기능의 품질과, 왜 특정 기능을 선택했는지 설명하는 것입니다.

### Q: 디자인이 약한데 큰 문제인가요?

**A**: 디자인은 25%의 가중치를 가지므로 중요하지만, 다른 영역에서 보완할 수 있습니다. 일관성과 깔끔함에 집중하세요.

### Q: AI 도구를 사용해도 되나요?

**A**: 네, ChatGPT나 Copilot 같은 도구를 사용할 수 있습니다. 하지만 생성된 코드를 이해하고 수정해야 하며, 전체 설계는 스스로 해야 합니다.

---

**최종 조언**: 평가자들은 완벽한 솔루션을 찾는 것이 아니라, **함께 일하고 싶은 개발자**를 찾고 있습니다. 사고 과정, 의사소통, 품질에 대한 관심을 보여주세요.
