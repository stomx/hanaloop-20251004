# 가짜 백엔드 구현 사양

## 개요

실제 백엔드 없이 프론트엔드 개발을 진행하기 위해, 네트워크 지연, I/O 시뮬레이션, 간헐적 실패를 포함한 가짜 API를 구현해야
합니다. 이를 통해 로딩 상태, 에러 처리, 낙관적 업데이트, 롤백 등을 현실적으로 테스트할 수 있습니다.

## 요구사항

### 1. 네트워크 지연 시뮬레이션

모든 API 호출은 **200~800ms**의 랜덤 지연을 가져야 합니다.

```typescript
const delay = (ms: number) => new Promise(res => setTimeout(res, ms));
const jitter = () => 200 + Math.random() * 600; // 200-800ms
```

### 2. 실패 시뮬레이션

쓰기 작업(생성, 수정, 삭제)은 **10~20%의 실패율**을 가져야 합니다.

```typescript
const maybeFail = () => Math.random() < 0.15; // 15% 실패율
```

### 3. 인메모리 데이터 저장

브라우저 세션 동안 데이터를 유지하기 위해 클라이언트 사이드 인메모리 저장소를 사용합니다.

```typescript
let _countries: Country[] = [...seedCountries];
let _companies: Company[] = [...seedCompanies];
let _posts: Post[] = [...seedPosts];
```

## API 구현

### 파일 구조

```
lib/
  ├── api.ts                 # 메인 API 모듈
  └── seed-data/
      ├── countries.ts       # 국가 시드 데이터
      ├── companies.ts       # 회사 및 배출량 시드 데이터
      └── posts.ts           # 포스트 시드 데이터
```

### API 함수 목록

#### Read Operations (읽기)

```typescript
// 모든 국가 조회
export async function fetchCountries(): Promise<Country[]>

// 모든 회사 조회
export async function fetchCompanies(): Promise<Company[]>

// 모든 포스트 조회
export async function fetchPosts(): Promise<Post[]>

// 특정 포스트 조회
export async function fetchPostById(id: string): Promise<Post | null>
```

#### Write Operations (쓰기)

```typescript
// 포스트 생성 또는 수정
export async function createOrUpdatePost(
  post: Omit<Post, 'id'> & { id?: string }
): Promise<Post>

// 포스트 삭제
export async function deletePost(id: string): Promise<void>
```

## 완전한 구현 예시

### lib/api.ts

```typescript
import { countries as seedCountries } from './seed-data/countries';
import { companies as seedCompanies } from './seed-data/companies';
import { posts as seedPosts } from './seed-data/posts';
import type { Country, Company, Post } from '@/types';

// In-memory data storage
let _countries: Country[] = [...seedCountries];
let _companies: Company[] = [...seedCompanies];
let _posts: Post[] = [...seedPosts];

// Utility functions
const delay = (ms: number) => new Promise(res => setTimeout(res, ms));
const jitter = () => 200 + Math.random() * 600; // 200-800ms
const maybeFail = () => Math.random() < 0.15; // 15% failure rate

// ========== READ OPERATIONS ==========

/**
 * Fetch all countries
 */
export async function fetchCountries(): Promise<Country[]> {
  await delay(jitter());
  return [..._countries];
}

/**
 * Fetch all companies with their emissions data
 */
export async function fetchCompanies(): Promise<Company[]> {
  await delay(jitter());
  return [..._companies];
}

/**
 * Fetch all posts
 */
export async function fetchPosts(): Promise<Post[]> {
  await delay(jitter());
  return [..._posts];
}

/**
 * Fetch a single post by ID
 */
export async function fetchPostById(id: string): Promise<Post | null> {
  await delay(jitter());
  const post = _posts.find(p => p.id === id);
  return post ? { ...post } : null;
}

// ========== WRITE OPERATIONS ==========

/**
 * Create a new post or update an existing one
 * @throws Error if save fails (15% chance)
 */
export async function createOrUpdatePost(
  post: Omit<Post, 'id'> & { id?: string }
): Promise<Post> {
  await delay(jitter());
  
  // Simulate random failure
  if (maybeFail()) {
    throw new Error('Failed to save post. Please try again.');
  }
  
  if (post.id) {
    // Update existing post
    const index = _posts.findIndex(p => p.id === post.id);
    if (index === -1) {
      throw new Error('Post not found');
    }
    
    const updated = { ...post, id: post.id } as Post;
    _posts[index] = updated;
    return { ...updated };
  } else {
    // Create new post
    const created: Post = {
      ...post,
      id: crypto.randomUUID(),
    };
    _posts = [..._posts, created];
    return { ...created };
  }
}

/**
 * Delete a post by ID
 * @throws Error if delete fails (15% chance)
 */
export async function deletePost(id: string): Promise<void> {
  await delay(jitter());
  
  // Simulate random failure
  if (maybeFail()) {
    throw new Error('Failed to delete post. Please try again.');
  }
  
  const index = _posts.findIndex(p => p.id === id);
  if (index === -1) {
    throw new Error('Post not found');
  }
  
  _posts = _posts.filter(p => p.id !== id);
}

// ========== HELPER FUNCTIONS (Optional) ==========

/**
 * Reset all data to initial seed values
 * Useful for testing or demo reset
 */
export function resetData(): void {
  _countries = [...seedCountries];
  _companies = [...seedCompanies];
  _posts = [...seedPosts];
}

/**
 * Get current state (for debugging)
 */
export function getDataSnapshot() {
  return {
    countries: [..._countries],
    companies: [..._companies],
    posts: [..._posts],
  };
}
```

## 시드 데이터 예시

### lib/seed-data/countries.ts

```typescript
import type { Country } from '@/types';

export const countries: Country[] = [
  { code: 'US', name: 'United States' },
  { code: 'DE', name: 'Germany' },
  { code: 'KR', name: 'South Korea' },
  { code: 'JP', name: 'Japan' },
  { code: 'CN', name: 'China' },
  { code: 'GB', name: 'United Kingdom' },
  { code: 'FR', name: 'France' },
];
```

### lib/seed-data/companies.ts

```typescript
import type { Company } from '@/types';

export const companies: Company[] = [
  {
    id: 'c1',
    name: 'Acme Corp',
    country: 'US',
    emissions: [
      { yearMonth: '2024-01', source: 'gasoline', emissions: 120 },
      { yearMonth: '2024-02', source: 'gasoline', emissions: 110 },
      { yearMonth: '2024-03', source: 'gasoline', emissions: 95 },
      { yearMonth: '2024-01', source: 'diesel', emissions: 50 },
      { yearMonth: '2024-02', source: 'diesel', emissions: 55 },
      { yearMonth: '2024-03', source: 'diesel', emissions: 48 },
    ],
  },
  {
    id: 'c2',
    name: 'Globex',
    country: 'DE',
    emissions: [
      { yearMonth: '2024-01', source: 'lpg', emissions: 80 },
      { yearMonth: '2024-02', source: 'lpg', emissions: 105 },
      { yearMonth: '2024-03', source: 'lpg', emissions: 120 },
      { yearMonth: '2024-01', source: 'natural gas', emissions: 30 },
      { yearMonth: '2024-02', source: 'natural gas', emissions: 35 },
      { yearMonth: '2024-03', source: 'natural gas', emissions: 32 },
    ],
  },
  {
    id: 'c3',
    name: 'Initech',
    country: 'KR',
    emissions: [
      { yearMonth: '2024-01', source: 'gasoline', emissions: 60 },
      { yearMonth: '2024-02', source: 'gasoline', emissions: 65 },
      { yearMonth: '2024-03', source: 'gasoline', emissions: 70 },
      { yearMonth: '2024-01', source: 'diesel', emissions: 25 },
      { yearMonth: '2024-02', source: 'diesel', emissions: 28 },
      { yearMonth: '2024-03', source: 'diesel', emissions: 30 },
    ],
  },
];
```

### lib/seed-data/posts.ts

```typescript
import type { Post } from '@/types';

export const posts: Post[] = [
  {
    id: 'p1',
    title: 'Q1 Sustainability Report',
    resourceUid: 'c1',
    dateTime: '2024-02',
    content: 'Quarterly CO2 update: emissions decreased by 8% compared to January.',
  },
  {
    id: 'p2',
    title: 'New Green Initiative',
    resourceUid: 'c2',
    dateTime: '2024-03',
    content: 'Implementing new solar panels to reduce natural gas dependency.',
  },
  {
    id: 'p3',
    title: 'Fleet Optimization',
    resourceUid: 'c3',
    dateTime: '2024-03',
    content: 'Transitioning company vehicles to hybrid models to reduce gasoline usage.',
  },
];
```

## 사용 예시

### React Query와 함께 사용

```typescript
// hooks/useCompanies.ts
import { useQuery } from '@tanstack/react-query';
import { fetchCompanies } from '@/lib/api';

export function useCompanies() {
  return useQuery({
    queryKey: ['companies'],
    queryFn: fetchCompanies,
    staleTime: 5 * 60 * 1000, // 5 minutes
  });
}
```

### 낙관적 업데이트 with 롤백

```typescript
// hooks/useCreatePost.ts
import { useMutation, useQueryClient } from '@tanstack/react-query';
import { createOrUpdatePost } from '@/lib/api';
import type { Post } from '@/types';

export function useCreatePost() {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: createOrUpdatePost,
    
    // Optimistic update
    onMutate: async (newPost) => {
      // Cancel outgoing refetches
      await queryClient.cancelQueries({ queryKey: ['posts'] });
      
      // Snapshot previous value
      const previousPosts = queryClient.getQueryData<Post[]>(['posts']);
      
      // Optimistically update
      if (previousPosts) {
        queryClient.setQueryData<Post[]>(['posts'], (old) => [
          ...(old || []),
          { ...newPost, id: 'temp-' + Date.now() } as Post,
        ]);
      }
      
      // Return snapshot for rollback
      return { previousPosts };
    },
    
    // Rollback on error
    onError: (err, newPost, context) => {
      if (context?.previousPosts) {
        queryClient.setQueryData(['posts'], context.previousPosts);
      }
    },
    
    // Refetch on success or error
    onSettled: () => {
      queryClient.invalidateQueries({ queryKey: ['posts'] });
    },
  });
}
```

## 테스트 시나리오

### 1. 로딩 상태 테스트

모든 API 호출이 200-800ms 지연되므로, 로딩 스피너나 스켈레톤이 표시되는지 확인합니다.

### 2. 에러 처리 테스트

여러 번 포스트를 저장하면 일부는 실패합니다. 에러 메시지가 표시되고 재시도 버튼이 작동하는지 확인합니다.

### 3. 낙관적 업데이트 테스트

포스트 생성 시 즉시 UI에 반영되고, 실패 시 롤백되는지 확인합니다.

### 4. 데이터 일관성 테스트

페이지를 새로고침하면 데이터가 초기 상태로 돌아가는지 확인합니다. (인메모리이므로 당연)

## 확장 가능성

### LocalStorage 지속성 추가 (선택사항)

```typescript
// Load from localStorage on init
const loadFromStorage = <T>(key: string, fallback: T): T => {
  if (typeof window === 'undefined') return fallback;
  const stored = localStorage.getItem(key);
  return stored ? JSON.parse(stored) : fallback;
};

// Save to localStorage after mutations
const saveToStorage = <T>(key: string, data: T): void => {
  if (typeof window !== 'undefined') {
    localStorage.setItem(key, JSON.stringify(data));
  }
};
```

### 서버 컴포넌트에서 사용 (Next.js)

```typescript
// app/dashboard/page.tsx
import { fetchCompanies } from '@/lib/api';

export default async function DashboardPage() {
  const companies = await fetchCompanies();
  
  return <Dashboard companies={companies} />;
}
```

## 주의사항

1. **서버 사이드 사용 제한**: 이 API는 클라이언트 사이드 전용입니다. Next.js 서버 컴포넌트에서 사용하려면 `'use client'` 또는 별도 처리가 필요합니다.

2. **데이터 휘발성**: 페이지 새로고침 시 데이터가 초기화됩니다. 지속성이 필요하면 localStorage를 추가하세요.

3. **동시성 처리 없음**: 여러 탭에서 동시에 수정 시 동기화되지 않습니다.

4. **실제 백엔드와의 차이**: 실제 환경에서는 인증, 권한, 유효성 검사 등이 추가로 필요합니다.
